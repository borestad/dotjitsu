#!/usr/bin/env bash
# ------------------------------------------------------------------------------
# sum-filesize - Calculate the total size (in bytes) of regular files read from stdin.
# ------------------------------------------------------------------------------
# Reads newline-delimited file paths from stdin and reports:
#   - Total size   (human-readable if numfmt is available)
#   - Total files  (count of regular files processed)
#
# Always runs in parallel
#
# Usage examples:
#   fd -e png | ./sum-filesize                 # auto parallel
#   rg -0 -l '\.(png|jpg)$' | tr '\0' '\n' | ./sum-filesize --jobs 12
#   git ls-files | ./sum-filesize
#
# Options:
#   --jobs N        Number of parallel workers (default: CPU count, max 16)
#   -j N            Alias for --jobs
#   --help, -h      Show this help
#
# Notes / Limitations:
#   * Filenames containing newlines are not supported (stdin expects one path per line)
#   * Only regular files (-f) counted; others are skipped silently
#   * Uses stat -c %s (GNU) or stat -f %z (BSD/macOS) depending on availability
#   * Parallel mode stages a temporary NUL list (disk I/O is cheaper than large shell arrays)
#
set -euo pipefail

print_help() {
  sed -n '2,/^set -euo/p' "$0" | sed '$d'
}


# Default settings
JOBS=$(nproc)
INPUT_PATH=""

# Globals updated by processing functions
total=0
file_count=0

parse_args() {
  # Parses CLI args and sets JOBS, INPUT_PATH
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --jobs|-j)
        JOBS=${2:-}
        [[ -n "$JOBS" ]] || { echo "Missing value for $1" >&2; exit 1; }
        shift 2
        ;;
      --help|-h)
        print_help; exit 0 ;;
      *)
        if [[ -z "$INPUT_PATH" ]]; then
          INPUT_PATH=$1
          shift
        else
          echo "Multiple input paths provided: $INPUT_PATH and $1" >&2
          exit 1
        fi
        ;;
    esac
  done
}

# Decide stat variant and populate STAT_CMD as an array
detect_stat_cmd() {
  if stat -c %s "$0" >/dev/null 2>&1; then
    STAT_CMD=(stat -c %s)
  elif stat -f %z "$0" >/dev/null 2>&1; then
    STAT_CMD=(stat -f %z)
  else
    echo "Unsupported stat implementation" >&2
    exit 1
  fi
}


process_files() {
  # Process files in parallel using a temp file and xargs
  tmp_list=$(mktemp -t sum-filesize.XXXXXX)
  trap 'rm -f "$tmp_list"' EXIT

  if [[ -n "$INPUT_PATH" ]]; then
    if [[ -d "$INPUT_PATH" ]]; then
      # Input is a directory, find all files
      find "$INPUT_PATH" -type f -print0 >"$tmp_list"
      file_count=$(tr -cd '\0' <"$tmp_list" | wc -c)
    elif [[ -f "$INPUT_PATH" ]]; then
      # Input is a single file
      printf '%s\0' "$INPUT_PATH" >"$tmp_list"
      file_count=1
    else
      echo "Path not found: $INPUT_PATH" >&2
      exit 1
    fi
  else
    # Read file paths from stdin
    while IFS= read -r path; do
      [[ -f "$path" ]] || continue
      printf '%s\0' "$path" >> "$tmp_list"
      ((file_count++)) || true
    done
  fi

  if [[ $file_count -eq 0 ]]; then
    echo "No files found."; exit 0
  fi

  sizes=$(xargs -0 -n1000 -P "$JOBS" "${STAT_CMD[@]}" <"$tmp_list" 2>/dev/null || true)

  if [[ -n "$sizes" ]]; then
    total=$(printf '%s\n' "$sizes" | awk '{s+=$1} END{print s}')
  fi
}

print_result() {
  if command -v numfmt >/dev/null 2>&1; then
    human=$(numfmt --to=iec --suffix=B "$total")
    echo "Total size:  $human"
  else
    echo "Total size:  $total bytes"
  fi
  echo "Total files: $file_count"
}

# Entry point
parse_args "$@"
detect_stat_cmd
process_files
print_result
