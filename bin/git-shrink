#!/usr/bin/env bash

#
# Shrink a Git repository by removing unnecessary objects and cleaning up the repository.
#
# This script removes all tags, clears the reflog, and runs garbage collection to reduce
# the repository size. It displays object counts before and after the operation.
#
# Usage:
#   git-shrink [OPTIONS]
#
# Options:
#   --aggressive    Use aggressive garbage collection (slower but more effective)
#   --help          Show this help message
#
# References:
#   https://stackoverflow.com/questions/38171899/how-to-reduce-the-depth-of-an-existing-git-clone/46004595#46004595
#

set -euo pipefail

# Colors - only use if stdout is a terminal
if [[ -t 1 ]]; then
  readonly CYAN='\033[0;36m'
  readonly GREEN='\033[0;32m'
  readonly YELLOW='\033[1;33m'
  readonly RED='\033[0;31m'
  readonly UNDERLINE='\033[4m'
  readonly NC='\033[0m'
else
  readonly CYAN=''
  readonly GREEN=''
  readonly YELLOW=''
  readonly RED=''
  readonly UNDERLINE=''
  readonly NC=''
fi

# Parse arguments
GC_ARGS="--prune=now"

for arg in "$@"; do
  case "$arg" in
    --aggressive)
      GC_ARGS="$GC_ARGS --aggressive"
      ;;
    --help)
      sed -n '/^#/p' "$0" | sed 's/^#[[:space:]]\?//'
      exit 0
      ;;
    *)
      echo "❌ Unknown option: $arg" >&2
      sed -n '/^#/p' "$0" | sed 's/^#[[:space:]]\?//' | head -20
      exit 1
      ;;
  esac
done

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
  echo -e "${RED}✗${NC} Not a git repository" >&2
  exit 1
fi

REPO_NAME=$(git rev-parse --show-toplevel | xargs basename)

# Start timing
START_TIME=$(date +%s%N)

# Helper function to get git stats
get_git_stats() {
  local output=$(git count-objects -vH 2>/dev/null)
  local loose=$(echo "$output" | grep '^count' | awk '{print $2}')
  local loose_size=$(echo "$output" | grep '^size' | head -1 | awk '{print $2}')
  local in_pack=$(echo "$output" | grep '^in-pack' | awk '{print $2}')
  local packs=$(echo "$output" | grep '^packs' | awk '{print $2}')
  local size_pack=$(echo "$output" | grep '^size-pack' | awk '{print $2}')
  local garbage=$(echo "$output" | grep '^garbage' | awk '{print $2}')

  # Ensure sizes have units
  [[ $loose_size =~ ^[0-9]+$ ]] && loose_size="${loose_size} bytes"
  [[ $size_pack =~ ^[0-9.]+$ ]] && size_pack="${size_pack} MB"

  # Return pipe-separated: loose|loose_size|in_pack|packs|size_pack|garbage
  echo "$loose|$loose_size|$in_pack|$packs|$size_pack|$garbage"
}

# Get size before
STATS_BEFORE=$(get_git_stats)
LOOSE_BEFORE=$(echo "$STATS_BEFORE" | cut -d'|' -f1)
LOOSE_SIZE_BEFORE=$(echo "$STATS_BEFORE" | cut -d'|' -f2)
IN_PACK_BEFORE=$(echo "$STATS_BEFORE" | cut -d'|' -f3)
PACKS_BEFORE=$(echo "$STATS_BEFORE" | cut -d'|' -f4)
SIZE_PACK_BEFORE=$(echo "$STATS_BEFORE" | cut -d'|' -f5)
GARBAGE_BEFORE=$(echo "$STATS_BEFORE" | cut -d'|' -f6)

# Display initial state
echo ""
echo -e "${CYAN}┌─${NC} git-shrink: before"
echo -e "${CYAN}│${NC}"
echo -e "${CYAN}│${NC}  - Loose:    $LOOSE_BEFORE objects ($LOOSE_SIZE_BEFORE)"
echo -e "${CYAN}│${NC}  - Packed:   $IN_PACK_BEFORE objects ($SIZE_PACK_BEFORE) in $PACKS_BEFORE pack"
echo -e "${CYAN}│${NC}  - Garbage:  $GARBAGE_BEFORE objects"
echo -e "${CYAN}│${NC}  - Total:    ${YELLOW}$SIZE_PACK_BEFORE${NC}"
echo -e "${CYAN}│${NC}"
echo -e "${CYAN}└─────────────────────────────────────────${NC}"
echo ""

# Execute cleanup steps silently (no visual output during operations)
git tag -l | xargs git tag -d > /dev/null 2>&1 || true
git rerere forget . > /dev/null 2>&1 || true
git reflog expire --expire=now --expire-unreachable=now --all > /dev/null 2>&1 || true

# Run gc with progress output
git gc $GC_ARGS
echo ""

# Get size after
STATS_AFTER=$(get_git_stats)
LOOSE_AFTER=$(echo "$STATS_AFTER" | cut -d'|' -f1)
LOOSE_SIZE_AFTER=$(echo "$STATS_AFTER" | cut -d'|' -f2)
IN_PACK_AFTER=$(echo "$STATS_AFTER" | cut -d'|' -f3)
PACKS_AFTER=$(echo "$STATS_AFTER" | cut -d'|' -f4)
SIZE_PACK_AFTER=$(echo "$STATS_AFTER" | cut -d'|' -f5)
GARBAGE_AFTER=$(echo "$STATS_AFTER" | cut -d'|' -f6)

# Calculate total sizes and savings
calculate_savings() {
  local loose_size_before=$1
  local size_pack_before=$2
  local loose_size_after=$3
  local size_pack_after=$4

  # Extract numeric values
  local loose_before_num=$(echo "$loose_size_before" | awk '{print $1}')
  local pack_before_num=$(echo "$size_pack_before" | awk '{print $1}')
  local loose_after_num=$(echo "$loose_size_after" | awk '{print $1}')
  local pack_after_num=$(echo "$size_pack_after" | awk '{print $1}')

  # Calculate totals (convert everything to MB, assuming loose_size is in bytes/KiB)
  # If loose_size is in bytes, convert to MB: bytes / 1048576
  if [[ "$loose_size_before" == *"bytes"* ]]; then
    loose_before_num=$(echo "scale=2; $loose_before_num / 1048576" | bc 2>/dev/null || echo "0")
  elif [[ "$loose_size_before" == *"KiB"* ]]; then
    loose_before_num=$(echo "scale=2; $loose_before_num / 1024" | bc 2>/dev/null || echo "0")
  fi
  
  if [[ "$loose_size_after" == *"bytes"* ]]; then
    loose_after_num=$(echo "scale=2; $loose_after_num / 1048576" | bc 2>/dev/null || echo "0")
  elif [[ "$loose_size_after" == *"KiB"* ]]; then
    loose_after_num=$(echo "scale=2; $loose_after_num / 1024" | bc 2>/dev/null || echo "0")
  fi

  # Total: loose + packed
  local total_before=$(echo "$loose_before_num + $pack_before_num" | bc 2>/dev/null || echo "0")
  local total_after=$(echo "$loose_after_num + $pack_after_num" | bc 2>/dev/null || echo "0")
  
  # Savings = what we had before - what we have now
  local saved=$(echo "$total_before - $total_after" | bc 2>/dev/null || echo "0")
  saved=$(printf "%.2f" "$saved")
  
  # Only calc percent if total_before > 0
  local percent="0"
  if (( $(echo "$total_before > 0" | bc -l) )); then
    percent=$(echo "scale=0; ($saved / $total_before) * 100" | bc 2>/dev/null || echo "0")
  fi
  
  echo "$saved MB ($percent%)"
}

SAVINGS=$(calculate_savings "$LOOSE_SIZE_BEFORE" "$SIZE_PACK_BEFORE" "$LOOSE_SIZE_AFTER" "$SIZE_PACK_AFTER")

# Extract just the numeric part of savings for color logic
SAVINGS_NUM=$(echo "$SAVINGS" | awk '{print $1}')

# Calculate elapsed time
END_TIME=$(date +%s%N)
ELAPSED_MS=$(( (END_TIME - START_TIME) / 1000000 ))
ELAPSED_S=$(echo "scale=1; $ELAPSED_MS / 1000" | bc)

# Helper function to determine indicator based on change
get_indicator() {
  local before=$1
  local after=$2
  local metric_type=$3  # "loose", "garbage", "size", "packs", "packed"

  # Extract numeric values
  local before_num=$(echo "$before" | awk '{print $1}')
  local after_num=$(echo "$after" | awk '{print $1}')

  # Check if values are equal (no change)
  if [[ "$before_num" == "$after_num" ]]; then
    echo "-"  # Dash = no change
    return
  fi

  # Determine if it's an improvement based on metric type
  case "$metric_type" in
    loose|garbage|size|packs)
      # For these: less is better
      if (( $(echo "$after_num < $before_num" | bc -l) )); then
        echo "✓"  # Checkmark = improvement
      else
        echo "-"  # Dash = no improvement
      fi
      ;;
    packed)
      # For packed objects: more is better (loose objects got packed)
      if (( $(echo "$after_num > $before_num" | bc -l) )); then
        echo "✓"  # Checkmark = improvement
      else
        echo "-"  # Dash = no improvement
      fi
      ;;
    *)
      echo "-"  # Default to no change
      ;;
  esac
}

# Display final state - Simplified layout
echo -e "${CYAN}┌─${NC} git-shrink: AFTER (⏱ ${ELAPSED_S}s)"
echo -e "${CYAN}│${NC}"

# Loose indicator
LOOSE_INDICATOR=$(get_indicator "$LOOSE_BEFORE" "$LOOSE_AFTER" "loose")
echo -e "${CYAN}│${NC}  $LOOSE_INDICATOR Loose:    $LOOSE_AFTER objects ($LOOSE_SIZE_BEFORE → $LOOSE_SIZE_AFTER)"

# Packed: show before→after for both count and size, plus packs change
PACKED_INDICATOR=$(get_indicator "$IN_PACK_BEFORE" "$IN_PACK_AFTER" "packed")

# Combined packed line with all transitions - show size before and after
echo -e "${CYAN}│${NC}  $PACKED_INDICATOR Packed:   $IN_PACK_AFTER objects ($SIZE_PACK_BEFORE → $SIZE_PACK_AFTER) in $PACKS_BEFORE → $PACKS_AFTER pack"

# Garbage indicator
GARBAGE_INDICATOR=$(get_indicator "$GARBAGE_BEFORE" "$GARBAGE_AFTER" "garbage")
echo -e "${CYAN}│${NC}  $GARBAGE_INDICATOR Garbage:  $GARBAGE_AFTER objects"

# Total size with color indicator
TOTAL_SIZE_BEFORE_NUM=$(echo "$SIZE_PACK_BEFORE" | awk '{print $1}')
TOTAL_SIZE_AFTER_NUM=$(echo "$SIZE_PACK_AFTER" | awk '{print $1}')
if (( $(echo "$TOTAL_SIZE_AFTER_NUM < $TOTAL_SIZE_BEFORE_NUM" | bc -l) )); then
  TOTAL_COLOR="${GREEN}"
  TOTAL_INDICATOR="✓"
else
  TOTAL_COLOR="${YELLOW}"
  TOTAL_INDICATOR="-"
fi
echo -e "${CYAN}│${NC}  $TOTAL_INDICATOR Total:    ${TOTAL_COLOR}$SIZE_PACK_BEFORE${NC} → $SIZE_PACK_AFTER"
echo -e "${CYAN}│${NC}"

# Saved with color
if [[ -n "$SAVINGS" && "$SAVINGS" != "0.00 MB (0%)" ]]; then
  # Check if SAVINGS_NUM is positive (means space was saved)
  if (( $(echo "$SAVINGS_NUM > 0" | bc -l) )); then
    SAVED_COLOR="${GREEN}"
    SAVED_INDICATOR="✓"
  else
    SAVED_COLOR="${YELLOW}"
    SAVED_INDICATOR="-"
  fi
else
  # No savings - no color
  SAVED_COLOR="${NC}"
  SAVED_INDICATOR="-"
fi

echo -e "${CYAN}│${NC}  $SAVED_INDICATOR Saved:    ${SAVED_COLOR}$SAVINGS${NC}"
echo -e "${CYAN}│${NC}"
echo -e "${CYAN}└─────────────────────────────────────────${NC}"
echo ""
