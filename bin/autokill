#!/usr/bin/env bash
#
# autokill - Monitor and kill processes based on CPU time, runtime, CPU usage, or port usage.
#
# Features:
#   - Monitor multiple processes by name.
#   - Kill processes exceeding max CPU time, max runtime, or max CPU %.
#   - Kill processes listening on specified TCP ports.
#   - Supports exact name match (default), regex match (--regex-match), and substring partial match (--partial-match).
#   - Filter processes by user (--user).
#   - Graceful shutdown with SIGTERM before SIGKILL, configurable grace period.
#   - Dry-run mode to preview actions without killing.
#   - Skip checks unless all target processes have been running a minimum time.
#   - Logging to file or stdout with stylish colored output.
#
# Requirements:
#   - gdate (GNU date) must be installed and in PATH.
#     On macOS, install coreutils (e.g., via brew) and ensure 'gdate' is available.
#
# Usage:
#   ./autokill [OPTIONS] process_name_or_:port [process_name_or_:port ...]
#
# Options:
#   --max-cpu-time N        Kill if CPU time (seconds) exceeds N.
#   --max-runtime N         Kill if runtime (seconds) exceeds N.
#   --max-cpu-percent N     Kill if current CPU % exceeds N.
#   --skip-min-runtime N    Skip all checks unless all processes have run at least N seconds.
#   --dry-run               Show what would be done, but do not kill.
#   --log-file FILE         Log output to FILE instead of stdout.
#   --grace-period N        Seconds to wait after SIGTERM before SIGKILL (default: 0).
#   --regex-match           Use regex matching on full command line (pgrep -f).
#   --partial-match         Use substring (case-insensitive) match on process name.
#   --user USERNAME         Only target processes owned by USERNAME.
#   --help                  Show this help and exit.
#
# Examples:
#   # Kill 'gdu-go' and 'node' if they've been running over 1 hour (3600s)
#   ./autokill --max-runtime 3600 gdu-go node
#
#   # Kill processes matching regex 'python.*script.py' if CPU time exceeds 600s
#   ./autokill --regex-match --max-cpu-time 600 "python.*script.py"
#
#   # Kill all processes whose names contain 'chrome' substring if CPU % is above 80%
#   ./autokill --partial-match --max-cpu-percent 80 chrome
#
#   # Kill all processes listening on port 8000
#   ./autokill --dry-run :8000
#
#   # Dry run example showing what would be killed without actual termination
#   ./autokill --dry-run --max-runtime 300 someprocess
#
#   # Only kill processes that have been running at least 5 minutes (300s)
#   ./autokill --skip-min-runtime 300 --max-runtime 3600 targetproc
#
#   # Log output to a file and wait 10 seconds for graceful shutdown before SIGKILL
#   ./autokill --log-file /var/log/autokill.log --grace-period 10 myproc
#

# Colors and symbols for stylish output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# ------------------------------------------------------------------------------
# Helpers
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# is-array-empty(arrayname)
#   Returns 0 if the array with the given name is empty, 1 otherwise.
#   Arguments:
#     arrayname - Name of the array to check
# ------------------------------------------------------------------------------
is-array-empty() {
  local arr_name="$1"
  eval "[[ \${#$arr_name[@]} -eq 0 ]]"
}

# ------------------------------------------------------------------------------
# is-set(varname)
#   Returns 0 if the variable with the given name is set (not empty), 1 otherwise.
#   Arguments:
#     varname - Name of the variable to check
# ------------------------------------------------------------------------------
is-set() {
  [[ -n "${!1}" ]]
}

# ------------------------------------------------------------------------------
# is-empty(varname)
#   Returns 0 if the variable with the given name is empty, 1 otherwise.
#   Arguments:
#     varname - Name of the variable to check
# ------------------------------------------------------------------------------
is-empty() {
  [[ -z "${!1}" ]]
}

# ------------------------------------------------------------------------------
# to-int(value)
#   Converts a value to an integer by removing any decimals.
#   Arguments:
#     value - The value to convert
# ------------------------------------------------------------------------------
to-int() {
  printf "%d" "${1%%.*}"
}

# ------------------------------------------------------------------------------
# process-exists(pid)
#   Returns 0 if a process with given PID exists, 1 otherwise.
# ------------------------------------------------------------------------------
process-exists() {
  local pid="$1"
  ps -p "$pid" &>/dev/null
}

# ------------------------------------------------------------------------------
# log(msg)
#   Logs a message to stdout or to a log file if specified.
#   Supports colored output.
# ------------------------------------------------------------------------------
log() {
  local msg="$1"
  if is-set "log_file"; then
    echo -e "$msg" >> "$log_file"
  else
    echo -e "$msg"
  fi
}

# ------------------------------------------------------------------------------
# info(msg)
#   Logs an informational message in cyan.
# ------------------------------------------------------------------------------
info() {
  log "${CYAN}[i] $1${NC}"
}

# ------------------------------------------------------------------------------
# success(msg)
#   Logs a success message in green.
# ------------------------------------------------------------------------------
success() {
  log "${GREEN}✔ $1${NC}"
}

# ------------------------------------------------------------------------------
# warn(msg)
#   Logs a warning message in yellow.
# ------------------------------------------------------------------------------
warn() {
  log "${YELLOW}⚠️  $1${NC}"
}

# ------------------------------------------------------------------------------
# error(msg)
#   Logs an error message in red.
# ------------------------------------------------------------------------------
error() {
  log "${RED}✖ $1${NC}"
}

# Check for gdate (GNU date)
if ! command -v gdate &>/dev/null; then
  error "gdate (GNU date) is required but not found. Install with: brew install coreutils"
  exit 1
fi


# Defaults and variables
max_cpu_time=""
max_runtime=""
max_cpu_percent=""
skip_min_runtime=0
dry_run=0
log_file=""
grace_period=0  # seconds to wait after SIGTERM before SIGKILL
regex_match=0
partial_match=0
processes=()
user=""

# ------------------------------------------------------------------------------
# print-usage()
#   Prints usage information and examples for the script.
# ------------------------------------------------------------------------------
print-usage() {
  cat <<EOF
Usage: $(basename "$0") [OPTIONS] process_name_or_:port [process_name_or_:port ...]

Options:
  --max-cpu-time N        Max CPU time in seconds
  --max-runtime N         Max runtime in seconds
  --max-cpu-percent N     Max CPU percentage
  --skip-min-runtime N    Skip checks unless all processes run at least N seconds
  --dry-run               Show what would be done, but don't kill
  --log-file FILE         Log output to FILE
  --grace-period N        Seconds to wait after SIGTERM before kill -9 (default: 0)
  --regex-match           Match process names with regex (uses pgrep -f)
  --partial-match         Match process names by substring (case-insensitive)
  --user USERNAME         Only target processes owned by USERNAME
  --help                  Show this help message and exit

Examples:
  # Kill 'gdu-go' and 'node' if they've been running over 1 hour (3600s)
  ./$(basename "$0") --max-runtime 3600 gdu-go node

  # Kill processes matching regex 'python.*script.py' if CPU time exceeds 600s
  ./$(basename "$0") --regex-match --max-cpu-time 600 "python.*script.py"

  # Kill all processes whose names contain 'chrome' substring if CPU % is above 80%
  ./$(basename "$0") --partial-match --max-cpu-percent 80 chrome

  # Kill all processes listening on port 8000
  ./$(basename "$0") --dry-run :8000

  # Dry run example showing what would be killed without actual termination
  ./$(basename "$0") --dry-run --max-runtime 300 someprocess

  # Only kill processes that have been running at least 5 minutes (300s)
  ./$(basename "$0") --skip-min-runtime 300 --max-runtime 3600 targetproc

  # Log output to a file and wait 10 seconds for graceful shutdown before SIGKILL
  ./$(basename "$0") --log-file /var/log/autokill.log --grace-period 10 myproc
EOF
}

# ------------------------------------------------------------------------------
# cpu-to-seconds(time_str)
#   Converts a CPU time string (e.g. "1:23:45") to seconds.
#   Arguments:
#     time_str - CPU time string
# ------------------------------------------------------------------------------
cpu-to-seconds() {
  local time_str="$1"
  if [[ "$time_str" =~ ([0-9]+)-([0-9]+):([0-9]+):([0-9]+) ]]; then
    echo $(( ${BASH_REMATCH[1]} * 86400 + ${BASH_REMATCH[2]} * 3600 + ${BASH_REMATCH[3]} * 60 + ${BASH_REMATCH[4]} ))
  elif [[ "$time_str" =~ ([0-9]+):([0-9]+):([0-9]+) ]]; then
    echo $(( ${BASH_REMATCH[1]} * 3600 + ${BASH_REMATCH[2]} * 60 + ${BASH_REMATCH[3]} ))
  elif [[ "$time_str" =~ ([0-9]+):([0-9]+) ]]; then
    echo $(( ${BASH_REMATCH[1]} * 60 + ${BASH_REMATCH[2]} ))
  else
    echo 0
  fi
}

# ------------------------------------------------------------------------------
# parse-arguments()
#   Parses command-line arguments and sets global variables.
#   Arguments:
#     "$@" - All command-line arguments
# ------------------------------------------------------------------------------
parse-arguments() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --max-cpu-time) max_cpu_time="$2"; shift 2 ;;
      --max-runtime) max_runtime="$2"; shift 2 ;;
      --max-cpu-percent) max_cpu_percent="$2"; shift 2 ;;
      --skip-min-runtime) skip_min_runtime="$2"; shift 2 ;;
      --dry-run) dry_run=1; shift ;;
      --log-file) log_file="$2"; shift 2 ;;
      --grace-period) grace_period="$2"; shift 2 ;;
      --regex-match) regex_match=1; shift ;;
      --partial-match) partial_match=1; shift ;;
      --user) user="$2"; shift 2 ;;
      --help) print-usage; exit 0 ;;
      *) processes+=("$1"); shift ;;
    esac
  done

  if is-array-empty "processes"; then
    print-usage
    exit 1
  fi
}

# Parse arguments
parse-arguments "$@"

# ------------------------------------------------------------------------------
# get-pids(procname)
#   Gets PIDs for a process name using exact, regex, or partial match.
#   Optionally filters by user.
#   Arguments:
#     procname - Process name to match
# ------------------------------------------------------------------------------
get-pids() {
  local procname="$1"
  local user_filter=""

  if is-set "user"; then
    user_filter="-u $user"
  fi

  if (( regex_match )); then
    pgrep $user_filter -f "$procname"
  elif (( partial_match )); then
    ps $user_filter -eo pid=,comm= | awk -v pat="$procname" 'tolower($2) ~ tolower(pat) { print $1 }'
  else
    pgrep $user_filter -x "$procname"
  fi
}

# ------------------------------------------------------------------------------
# get-pids-on-port(port)
#   Gets PIDs and commands for processes listening on a TCP port.
#   Optionally filters by user.
#   Arguments:
#     port - TCP port number
# ------------------------------------------------------------------------------
get-pids-on-port() {
  local port="$1"
  # macOS uses lsof -i TCP:port to get PIDs listening on a port
  # Filter by user if requested
  if is-set "user"; then
    lsof -nP -i TCP:"$port" -sTCP:LISTEN -a -u "$user" 2>/dev/null | awk 'NR>1 {print $2, $1}'
  else
    lsof -nP -i TCP:"$port" -sTCP:LISTEN 2>/dev/null | awk 'NR>1 {print $2, $1}'
  fi
}

# ------------------------------------------------------------------------------
# graceful-kill(pid)
#   Sends SIGTERM to a process, waits for grace period, then sends SIGKILL.
#   Honors dry-run mode.
#   Arguments:
#     pid - Process ID to kill
# ------------------------------------------------------------------------------
graceful-kill() {
  local pid="$1"

  if (( dry_run )); then
    info "    Would send SIGTERM to PID $pid (dry-run)"
    if (( grace_period > 0 )); then
      info "    Would wait $grace_period seconds before SIGKILL (dry-run)"
    fi
    return
  fi

  kill "$pid" 2>/dev/null
  if (( grace_period > 0 )); then
    sleep "$grace_period"
  fi
  kill -9 "$pid" 2>/dev/null
}

# Separate port targets and name targets
port_targets=()
name_targets=()

for target in "${processes[@]}"; do
  if [[ "$target" =~ ^:([0-9]+)$ ]]; then
    port_targets+=("${BASH_REMATCH[1]}")
  else
    name_targets+=("$target")
  fi
done

# ------------------------------------------------------------------------------
# skip_min_runtime check for name targets
#   Skips all checks unless all processes have run at least skip_min_runtime seconds.
# ------------------------------------------------------------------------------
if (( skip_min_runtime > 0 )); then
  for proc in "${name_targets[@]}"; do
    pids=$(get-pids "$proc")
    if is-empty "pids"; then
      warn "$proc is not running. Skipping all checks."
      exit 0
    fi

    # Use a while-read loop to handle spaces safely
    while IFS= read -r pid; do
      start_time=$(ps -p "$pid" -o lstart=)
      start_epoch=$(gdate -d "$start_time" +%s)
      now_epoch=$(gdate +%s)
      runtime=$(( now_epoch - start_epoch ))

      if (( runtime < skip_min_runtime )); then
        warn "Process $proc PID $pid runtime $runtime sec < skip-min-runtime $skip_min_runtime sec. Skipping all checks."
        exit 0
      fi
    done <<< "$pids"
  done
fi

total_checked=0
total_killed=0

# ------------------------------------------------------------------------------
# get-process-info(pid)
#   Gets process info by PID.
#   Returns: runtime (seconds), cpu_seconds (CPU time in seconds), cpu_percent (current CPU usage %)
#   Arguments:
#     pid - Process ID
# ------------------------------------------------------------------------------
get-process-info() {
  local pid="$1"
  local info=()

  if process-exists "$pid"; then
    local start_time=$(ps -p "$pid" -o lstart=)
    local start_epoch=$(gdate -d "$start_time" +%s)
    local now_epoch=$(gdate +%s)
    local runtime=$(( now_epoch - start_epoch ))

    local cpu_time_str=$(ps -p "$pid" -o cputime= | awk '{$1=$1;print}')
    local cpu_seconds=$(cpu-to-seconds "$cpu_time_str")

    local cpu_percent=$(ps -p "$pid" -o %cpu= | awk '{$1=$1;print}')
    if ! [[ "$cpu_percent" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
      cpu_percent=0
    fi
  else
    runtime=0
    cpu_seconds=0
    cpu_percent=0
  fi

  info+=("$runtime" "$cpu_seconds" "$cpu_percent")
  echo "${info[@]}"
}

# ------------------------------------------------------------------------------
# should-kill-process(runtime, cpu_seconds, cpu_percent)
#   Checks if process should be killed based on thresholds.
#   Returns: reason string if process should be killed, empty string otherwise.
#   Arguments:
#     runtime      - Process runtime in seconds
#     cpu_seconds  - CPU time in seconds
#     cpu_percent  - Current CPU usage %
# ------------------------------------------------------------------------------
should-kill-process() {
  local runtime="$1"
  local cpu_seconds="$2"
  local cpu_percent="$3"

  local reason=""

  if is-set "max_cpu_time" && (( cpu_seconds > max_cpu_time )); then
    reason="CPU time exceeded (${cpu_seconds}s > ${max_cpu_time}s)"
  fi

  if is-empty "reason" && is-set "max_runtime" && (( runtime > max_runtime )); then
    reason="Runtime exceeded (${runtime}s > ${max_runtime}s)"
  fi

  if is-empty "reason" && is-set "max_cpu_percent"; then
    local cpu_percent_int=$(to-int "$cpu_percent")
    if (( cpu_percent_int > max_cpu_percent )); then
      reason="CPU % exceeded (${cpu_percent}% > ${max_cpu_percent}%)"
    fi
  fi

  echo "$reason"
}

# ------------------------------------------------------------------------------
# print-process-stats(pid, cmd, runtime, cpu_seconds, cpu_percent)
#   Pretty-prints process statistics for logging.
#   Arguments:
#     pid         - Process ID
#     cmd         - Command name
#     runtime     - Runtime in seconds
#     cpu_seconds - CPU time in seconds
#     cpu_percent - Current CPU usage %
# ------------------------------------------------------------------------------
print-process-stats() {
  local pid="$1"
  local cmd="$2"
  local runtime="$3"
  local cpu_seconds="$4"
  local cpu_percent="$5"

  if is-set "cmd"; then
    info "  PID $pid ($cmd):"
  else
    info "  PID $pid:"
  fi

  info "    Runtime       : ${runtime}s"
  info "    CPU time      : ${cpu_seconds}s"
  info "    Current CPU % : ${cpu_percent}%"
}

# ------------------------------------------------------------------------------
# handle-pid(pid, cmd)
#   Checks process stats, prints them, and kills the process if thresholds are exceeded.
#   Arguments:
#     pid - Process ID
#     cmd - Command name
# ------------------------------------------------------------------------------
handle-pid() {
  local pid="$1"
  local cmd="$2"

  total_checked=$(( total_checked + 1 ))

  read runtime cpu_seconds cpu_percent < <(get-process-info "$pid")

  print-process-stats "$pid" "$cmd" "$runtime" "$cpu_seconds" "$cpu_percent"

  local kill_reason
  kill_reason=$(should-kill-process "$runtime" "$cpu_seconds" "$cpu_percent")

  if is-set "kill_reason"; then
    if is-set "cmd"; then
      error "    ✖ Killing PID $pid ($cmd): $kill_reason"
    else
      error "    ✖ Killing PID $pid: $kill_reason"
    fi

    graceful-kill "$pid"
    total_killed=$(( total_killed + 1 ))
  fi
}

# ------------------------------------------------------------------------------
# handle-name-targets()
#   Handles all process name targets: finds PIDs, checks stats, kills if needed.
# ------------------------------------------------------------------------------
handle-name-targets() {
  for proc_name in "${name_targets[@]}"; do
    local pids
    pids=$(get-pids "$proc_name")

    if is-empty "pids"; then
      warn "$proc_name is not running."
      continue
    fi

    info "$proc_name is running:"

    while IFS= read -r pid; do
      handle-pid "$pid" ""
    done <<< "$pids"
  done
}

# ------------------------------------------------------------------------------
# handle-port-targets()
#   Handles all port targets: finds PIDs listening on ports, checks stats, kills if needed.
# ------------------------------------------------------------------------------
handle-port-targets() {
  for port in "${port_targets[@]}"; do

    local port_pids_cmds=()
    while IFS= read -r line; do
      port_pids_cmds+=("$line")
    done < <(get-pids-on-port "$port")

    if is-array-empty "port_pids_cmds"; then
      warn "No processes found listening on port $port. Skipping all checks."
      continue
    fi

    info "Processes listening on port $port:"

    for entry in "${port_pids_cmds[@]}"; do
      local pid="${entry%% *}"
      local cmd="${entry#* }"
      handle-pid "$pid" "$cmd"
    done

  done
}

# ------------------------------------------------------------------------------
# print-summary()
#   Prints a summary of checked and killed processes.
# ------------------------------------------------------------------------------
print-summary() {
  echo
  success "Summary:"
  info "  Processes checked: $total_checked"
  info "  Processes killed : $total_killed"
}

# ------------------------------------------------------------------------------
# Main: Entry point
# ------------------------------------------------------------------------------

# Parse arguments
parse-arguments "$@"

# 1. Handle all process name targets: find PIDs, check stats, and kill if needed
handle-name-targets

# 2. Handle all port targets: find PIDs listening on ports, check stats, and kill if needed
handle-port-targets

# 3. Print a summary of the processes checked and killed
print-summary

exit $total_killed
